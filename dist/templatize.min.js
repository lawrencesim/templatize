(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["Templatize"] = factory();
	else
		root["Templatize"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// CONCATENATED MODULE: ./node_modules/d3-format/src/formatDecimal.js
/* harmony default export */ var formatDecimal = (function(x) {
  return Math.abs(x = Math.round(x)) >= 1e21
      ? x.toLocaleString("en").replace(/,/g, "")
      : x.toString(10);
});

// Computes the decimal coefficient and exponent of the specified number x with
// significant digits p, where x is positive and p is in [1, 21] or undefined.
// For example, formatDecimalParts(1.23) returns ["123", 0].
function formatDecimalParts(x, p) {
  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, Â±Infinity
  var i, coefficient = x.slice(0, i);

  // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
  // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x.slice(i + 1)
  ];
}

// CONCATENATED MODULE: ./node_modules/d3-format/src/exponent.js


/* harmony default export */ var src_exponent = (function(x) {
  return x = formatDecimalParts(Math.abs(x)), x ? x[1] : NaN;
});

// CONCATENATED MODULE: ./node_modules/d3-format/src/formatGroup.js
/* harmony default export */ var formatGroup = (function(grouping, thousands) {
  return function(value, width) {
    var i = value.length,
        t = [],
        j = 0,
        g = grouping[0],
        length = 0;

    while (i > 0 && g > 0) {
      if (length + g + 1 > width) g = Math.max(1, width - length);
      t.push(value.substring(i -= g, i + g));
      if ((length += g + 1) > width) break;
      g = grouping[j = (j + 1) % grouping.length];
    }

    return t.reverse().join(thousands);
  };
});

// CONCATENATED MODULE: ./node_modules/d3-format/src/formatNumerals.js
/* harmony default export */ var formatNumerals = (function(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
});

// CONCATENATED MODULE: ./node_modules/d3-format/src/formatSpecifier.js
// [[fill]align][sign][symbol][0][width][,][.precision][~][type]
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;

function formatSpecifier(specifier) {
  if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
  var match;
  return new FormatSpecifier({
    fill: match[1],
    align: match[2],
    sign: match[3],
    symbol: match[4],
    zero: match[5],
    width: match[6],
    comma: match[7],
    precision: match[8] && match[8].slice(1),
    trim: match[9],
    type: match[10]
  });
}

formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof

function FormatSpecifier(specifier) {
  this.fill = specifier.fill === undefined ? " " : specifier.fill + "";
  this.align = specifier.align === undefined ? ">" : specifier.align + "";
  this.sign = specifier.sign === undefined ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === undefined ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === undefined ? undefined : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === undefined ? undefined : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === undefined ? "" : specifier.type + "";
}

FormatSpecifier.prototype.toString = function() {
  return this.fill
      + this.align
      + this.sign
      + this.symbol
      + (this.zero ? "0" : "")
      + (this.width === undefined ? "" : Math.max(1, this.width | 0))
      + (this.comma ? "," : "")
      + (this.precision === undefined ? "" : "." + Math.max(0, this.precision | 0))
      + (this.trim ? "~" : "")
      + this.type;
};

// CONCATENATED MODULE: ./node_modules/d3-format/src/formatTrim.js
// Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.
/* harmony default export */ var formatTrim = (function(s) {
  out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
    switch (s[i]) {
      case ".": i0 = i1 = i; break;
      case "0": if (i0 === 0) i0 = i; i1 = i; break;
      default: if (!+s[i]) break out; if (i0 > 0) i0 = 0; break;
    }
  }
  return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
});

// CONCATENATED MODULE: ./node_modules/d3-format/src/formatPrefixAuto.js


var prefixExponent;

/* harmony default export */ var formatPrefixAuto = (function(x, p) {
  var d = formatDecimalParts(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1],
      i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
      n = coefficient.length;
  return i === n ? coefficient
      : i > n ? coefficient + new Array(i - n + 1).join("0")
      : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
      : "0." + new Array(1 - i).join("0") + formatDecimalParts(x, Math.max(0, p + i - 1))[0]; // less than 1y!
});

// CONCATENATED MODULE: ./node_modules/d3-format/src/formatRounded.js


/* harmony default export */ var formatRounded = (function(x, p) {
  var d = formatDecimalParts(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
      : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
      : coefficient + new Array(exponent - coefficient.length + 2).join("0");
});

// CONCATENATED MODULE: ./node_modules/d3-format/src/formatTypes.js




/* harmony default export */ var formatTypes = ({
  "%": (x, p) => (x * 100).toFixed(p),
  "b": (x) => Math.round(x).toString(2),
  "c": (x) => x + "",
  "d": formatDecimal,
  "e": (x, p) => x.toExponential(p),
  "f": (x, p) => x.toFixed(p),
  "g": (x, p) => x.toPrecision(p),
  "o": (x) => Math.round(x).toString(8),
  "p": (x, p) => formatRounded(x * 100, p),
  "r": formatRounded,
  "s": formatPrefixAuto,
  "X": (x) => Math.round(x).toString(16).toUpperCase(),
  "x": (x) => Math.round(x).toString(16)
});

// CONCATENATED MODULE: ./node_modules/d3-format/src/identity.js
/* harmony default export */ var identity = (function(x) {
  return x;
});

// CONCATENATED MODULE: ./node_modules/d3-format/src/locale.js









var map = Array.prototype.map,
    prefixes = ["y","z","a","f","p","n","Âµ","m","","k","M","G","T","P","E","Z","Y"];

/* harmony default export */ var src_locale = (function(locale) {
  var group = locale.grouping === undefined || locale.thousands === undefined ? identity : formatGroup(map.call(locale.grouping, Number), locale.thousands + ""),
      currencyPrefix = locale.currency === undefined ? "" : locale.currency[0] + "",
      currencySuffix = locale.currency === undefined ? "" : locale.currency[1] + "",
      decimal = locale.decimal === undefined ? "." : locale.decimal + "",
      numerals = locale.numerals === undefined ? identity : formatNumerals(map.call(locale.numerals, String)),
      percent = locale.percent === undefined ? "%" : locale.percent + "",
      minus = locale.minus === undefined ? "â" : locale.minus + "",
      nan = locale.nan === undefined ? "NaN" : locale.nan + "";

  function newFormat(specifier) {
    specifier = formatSpecifier(specifier);

    var fill = specifier.fill,
        align = specifier.align,
        sign = specifier.sign,
        symbol = specifier.symbol,
        zero = specifier.zero,
        width = specifier.width,
        comma = specifier.comma,
        precision = specifier.precision,
        trim = specifier.trim,
        type = specifier.type;

    // The "n" type is an alias for ",g".
    if (type === "n") comma = true, type = "g";

    // The "" type, and any invalid type, is an alias for ".12~g".
    else if (!formatTypes[type]) precision === undefined && (precision = 12), trim = true, type = "g";

    // If zero fill is specified, padding goes after sign and before digits.
    if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";

    // Compute the prefix and suffix.
    // For SI-prefix, the suffix is lazily computed.
    var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
        suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";

    // What format function should we use?
    // Is this an integer type?
    // Can this type generate exponential notation?
    var formatType = formatTypes[type],
        maybeSuffix = /[defgprs%]/.test(type);

    // Set the default precision if not specified,
    // or clamp the specified precision to the supported range.
    // For significant precision, it must be in [1, 21].
    // For fixed precision, it must be in [0, 20].
    precision = precision === undefined ? 6
        : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
        : Math.max(0, Math.min(20, precision));

    function format(value) {
      var valuePrefix = prefix,
          valueSuffix = suffix,
          i, n, c;

      if (type === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;

        // Determine the sign. -0 is not less than 0, but 1 / -0 is!
        var valueNegative = value < 0 || 1 / value < 0;

        // Perform the initial formatting.
        value = isNaN(value) ? nan : formatType(Math.abs(value), precision);

        // Trim insignificant zeros.
        if (trim) value = formatTrim(value);

        // If a negative value rounds to zero after formatting, and no explicit positive sign is requested, hide the sign.
        if (valueNegative && +value === 0 && sign !== "+") valueNegative = false;

        // Compute the prefix and suffix.
        valuePrefix = (valueNegative ? (sign === "(" ? sign : minus) : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
        valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");

        // Break the formatted value into the integer âvalueâ part that can be
        // grouped, and fractional or exponential âsuffixâ part that is not.
        if (maybeSuffix) {
          i = -1, n = value.length;
          while (++i < n) {
            if (c = value.charCodeAt(i), 48 > c || c > 57) {
              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
              value = value.slice(0, i);
              break;
            }
          }
        }
      }

      // If the fill character is not "0", grouping is applied before padding.
      if (comma && !zero) value = group(value, Infinity);

      // Compute the padding.
      var length = valuePrefix.length + value.length + valueSuffix.length,
          padding = length < width ? new Array(width - length + 1).join(fill) : "";

      // If the fill character is "0", grouping is applied after padding.
      if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

      // Reconstruct the final output based on the desired alignment.
      switch (align) {
        case "<": value = valuePrefix + value + valueSuffix + padding; break;
        case "=": value = valuePrefix + padding + value + valueSuffix; break;
        case "^": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;
        default: value = padding + valuePrefix + value + valueSuffix; break;
      }

      return numerals(value);
    }

    format.toString = function() {
      return specifier + "";
    };

    return format;
  }

  function formatPrefix(specifier, value) {
    var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)),
        e = Math.max(-8, Math.min(8, Math.floor(src_exponent(value) / 3))) * 3,
        k = Math.pow(10, -e),
        prefix = prefixes[8 + e / 3];
    return function(value) {
      return f(k * value) + prefix;
    };
  }

  return {
    format: newFormat,
    formatPrefix: formatPrefix
  };
});

// CONCATENATED MODULE: ./node_modules/d3-format/src/defaultLocale.js


var defaultLocale_locale;
var defaultLocale_format;
var defaultLocale_formatPrefix;

defaultLocale({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});

function defaultLocale(definition) {
  defaultLocale_locale = src_locale(definition);
  defaultLocale_format = defaultLocale_locale.format;
  defaultLocale_formatPrefix = defaultLocale_locale.formatPrefix;
  return defaultLocale_locale;
}

// CONCATENATED MODULE: ./src/helpers.js

/* harmony default export */ var helpers = ({
  findTag: function findTag(content, delimiters, tag, options) {
    return this.__findTag(content, delimiters, tag, options);
    if (!closing) return open;
  },
  findSection: function findSection(content, delimiters, tag, options) {
    // copy options so we don't modified source obj
    if (!options || !options.as || !options.as.length) throw "Opening section tag must have leading directive";
    var optOpen = {},
        optClose = {};

    for (var key in options) {
      if (key === "split") throw "Section tags cannot have trailing directives";
      optOpen[key] = options[key];
      optClose[key] = key === "as" ? "/" : options[key];
    } // find opening tag


    var open = this.findTag(content, delimiters, tag, optOpen),
        close; // find closing tag

    close = this.__findTag(content, delimiters, tag, optClose);
    if (!open && !close) return null;
    if (!open || close.start < open.start) throw "Improper section nesting (for: #".concat(tag, ")"); // section object

    function newSection(open, parent) {
      return {
        open: open,
        close: null,
        as: open.as,
        nest: [],
        inner: [],
        _up: parent
      };
    } // parse for possible nested structure


    var current = newSection(open),
        root = current,
        next,
        i = 0;
    optOpen.search = current.open.end;

    while (++i) {
      if (i > 100) throw "Section search call stack size exceeded (for: #".concat(tag, ")"); // find all nested opening tag

      next = this.__findTag(content, delimiters, tag, optOpen); // continue pushing to inner level if still can

      if (next && next.start < close.start) {
        current.nest.push(newSection(next, current));
        current = current.nest[current.nest.length - 1];
        optOpen.search = current.open.end;
        continue;
      } // at inner-most, unhandled tag, close tag


      current.close = close; // parse inner content, exclude whatever nested

      if (!current.nest.length) {
        current.inner = [content.slice(current.open.end, current.close.start)];
      } else {
        (function () {
          var sliceFrom = current.open.end;
          current.inner = [];
          current.nest.forEach(function (child, i) {
            current.inner.push(content.slice(sliceFrom, child.open.start));
            sliceFrom = child.close.end;
          });
          current.inner.push(content.slice(sliceFrom, current.close.start));
        })();
      }

      if (current._up) {
        // find next closing tag
        optClose.search = current.close.end;
        close = this.__findTag(content, delimiters, tag, optClose);
        if (!close) throw "Improper section nesting (for: #".concat(tag, ")"); // pop level, cleanup "up" reference

        next = current;
        current = current._up;
        delete next._up;
      } else {
        // break condition
        delete current._up;
        break;
      }
    }

    return root;
  },
  __findTag: function __findTag(content, delimiters, tag, options) {
    options = options || {};
    var as = options.as || false,
        split = options.split || false,
        search = options.search || 0;
    if (as && !Array.isArray(as)) as = [as];
    if (split && !Array.isArray(split)) split = [split];
    var open = -1,
        start = -1,
        close = -1,
        directives = [],
        asIndex,
        inner; // find opening tag

    while (true) {
      // find opening delimiter
      open = this.indexOf(content, delimiters[0], search);
      if (!~open) return null;
      start = open + delimiters[0].length; // find closing delimiter

      close = this.indexOf(content, delimiters[1], search);
      if (!~close) return null; // update position and grab content

      search = close + delimiters[1].length;
      inner = content.slice(start, close).trim(); // verify as directive, if specified

      asIndex = -1;

      if (as) {
        asIndex = as.indexOf(inner[0]);
        if (!~asIndex) continue;
        inner = inner.slice(1);
      } // split by directives, if specified


      if (split && split.length) {
        inner = [inner];
        split.forEach(function (s) {
          var len = inner.length;

          if (len > 1) {
            --len;
            inner = inner.slice(0, len).concat(inner[len].split(s));
          } else {
            inner = inner[0].split(s);
          }
        });
        if (inner.length > 1) directives = inner.slice(1);
        inner = inner[0];
      }

      if (tag === undefined || inner === tag) {
        return {
          as: ~asIndex ? as[asIndex] : undefined,
          start: open,
          end: search,
          directives: directives
        };
      }
    }
  },
  indexOf: function indexOf(html, search, indexStart) {
    var index = html.indexOf(search, indexStart || 0); // ignores escaped

    while (index > 0 && html[index - 1] === "!") {
      index = html.indexOf(search, index + search.length);
    }

    return index;
  },
  format: function format(value, _format) {
    if (value === null || value === undefined) return "";
    value = value.toString();
    if (!_format) return value;

    if (!isNaN(value) && !isNaN(parseFloat(value))) {
      return defaultLocale_format(_format)(value);
    }

    if (_format.startsWith("^")) {
      value = this.escape(value);
      _format = _format.slice(1);
    }

    switch (_format) {
      case "encode":
        return this.escape(value);

      case "upper":
        return value.toUpperCase();

      case "lower":
        return value.toLowerCase();

      case "capitalize":
        return value.replace(/(?:^|[^\w])[a-z]/g, function (match) {
          return match === "'s" ? match : match.toUpperCase();
        });
    }

    return value;
  },
  escape: function escape(value) {
    return value.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
  }
});
// CONCATENATED MODULE: ./src/templatize.js
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }



var templatize_Interface = function Interface(options) {
  options = options || {};
  this.__delimiters = options.delimiters || ["{{", "}}"]; // flag for throwing error on function evaluation

  this.errorOnFuncFailure = options.errorOnFuncFailure || false; // flag for treating 0 as true for section evaluation

  this.evalZeroAsTrue = options.evalZeroAsTrue || false; // for internally persistent data

  this.__data;

  this.render = function (html, bindings, cleanup) {
    this.__data = {
      html: html,
      root: bindings
    };

    var rendered = this.__render(this.__data.html, bindings, null);

    rendered = this.__renderValue(rendered, undefined, "", "!"); // cleanup comments

    if (cleanup) rendered = this.__renderValue(rendered, undefined, ""); // cleanup orphaned tags

    return rendered;
  };

  this.__render = function (html, bindings, prefix) {
    if (!html) return ""; // render section for subsections as nested objects

    var inSection = false;

    if (prefix !== null && prefix !== undefined) {
      inSection = true;
      var display = !("_display" in bindings) || bindings["_display"];
      html = this.__renderSection(html, prefix, display);
    } // prep prefix for next level


    var usePrefix = inSection ? prefix + "." : "",
        value,
        path;

    for (var key in bindings) {
      // skip reserved values
      if (key === "_display" || key === "_parent") continue;
      value = bindings[key];
      key = key.trim(); // strip leading/trailing whitespace

      path = usePrefix + key; // full key path from root
      // special cases

      if (value) {
        // if an array, treat as repeating section
        if (Array.isArray(value)) {
          html = this.__renderList(html, path, value, bindings), // list formatting
          html = this.__renderRepeatingSection(html, path, value, bindings);
          continue;
        }

        switch (_typeof(value)) {
          case "function":
            try {
              // skip naked evaluation if marked as contextual only
              if (key.startsWith("~")) continue; // duplicate function result into emulated binding

              var rebind = {};
              rebind[path] = value.call(bindings);
              if (!rebind._parent) rebind._parent = bindings; // recurse to apply by result type

              html = this.__render(html, rebind, null);
              continue;
            } catch (e) {
              // set error if functions errors, otherwise continue with blank to remove tags
              if (this.errorOnFuncFailure) throw e;
              console.error(e);
              value = "";
              break;
            }

          case "object":
            if (!value._parent) value._parent = bindings; // add parent context
            // check to render as function context

            html = this.__renderFunctionContext(html, path, value); // recurse into

            html = this.__render(html, value, path);
            delete value._parent;
            break;
        }
      } // display/hide section (after having checked for repeating)


      html = this.__renderSection(html, path, value); // render simple tags

      html = this.__renderValue(html, path, value);
    }

    return html;
  };

  this.__renderValue = function (html, tag, value, as) {
    var opts = {
      split: ["::"],
      as: as || false
    },
        find = helpers.findTag(html, this.__delimiters, tag, opts);

    while (find) {
      var format = find.directives.length ? find.directives[0] : false,
          fvalue = helpers.format(value, format);
      html = html.slice(0, find.start) + fvalue + html.slice(find.end);
      opts.search = find.start + fvalue.length;
      find = helpers.findTag(html, this.__delimiters, tag, opts);
    }

    return html;
  };

  this.__renderList = function (html, tag, bindings, context) {
    var _this = this;

    var opts = {
      split: ["::"],
      as: "&"
    },
        find = helpers.findTag(html, this.__delimiters, tag, opts);

    var _loop = function _loop() {
      var format = find.directives.length ? find.directives[0] : false,
          values = bindings.map(function (val) {
        if (Array.isArray(val)) throw "Multi-dimensional arrays not supported (for: ".concat(tag, ")"); // if function try to evaluate, but must eventually return object or primitive

        var b = 0;

        while (typeof val === "function" && ++b <= 20) {
          val = val.call(context);
        }

        if (_typeof(val) === "object") throw "List items cannot be objects (for: ".concat(tag, ")");
        return helpers.format(val, format);
      });
      var listStr = void 0;

      switch (values.length) {
        case 1:
          listStr = values[0];
          break;

        case 2:
          listStr = "".concat(values[0], " and ").concat(values[1]);
          break;

        default:
          listStr = "";
          values.forEach(function (item, i) {
            listStr += "".concat(i ? ", " : "").concat(i + 1 === values.length ? "and " : "").concat(item);
          });
      }

      html = html.slice(0, find.start) + listStr + html.slice(find.end);
      opts.search = find.start + listStr.length;
      find = helpers.findTag(html, _this.__delimiters, tag, opts);
    };

    while (find) {
      _loop();
    }

    return html;
  };

  this.__renderSectionAbstract = function (html, tag, as, render) {
    var options = {
      search: 0,
      as: as
    },
        section,
        rendered;

    while (true) {
      section = helpers.findSection(html, this.__delimiters, tag, options);
      if (!section) break;
      rendered = render(section);
      html = html.slice(0, section.open.start) + rendered + html.slice(section.close.end);
      options.search = section.open.start + rendered.length;
    }

    return html;
  };

  this.__renderSection = function (html, tag, display) {
    display = this.evalZeroAsTrue && display === 0 || // if set to, evaluate strict 0 as true
    display && (typeof display !== "string" || display.trim().length) // only-whitespace is false
    ; // render sections from outermost-in (until non-display hit)

    function render(section) {
      if (section.as === "#" ? !display : display) return "";
      var pieces = [section.inner[0]];
      section.nest.forEach(function (child, i) {
        pieces.push(render(child), section.inner[i + 1]);
      });
      return pieces.join("");
    }

    return this.__renderSectionAbstract(html, tag, ["#", "^"], render);
  };

  this.__renderRepeatingSection = function (html, tag, bindings, context) {
    var _this2 = this;

    // build and render sections from inside-out
    var render = function render(section) {
      var template = section.inner[0];
      section.nest.forEach(function (child, i) {
        template += render(child) + section.inner[i + 1];
      });
      var rendered = "";
      bindings.forEach(function (item) {
        if (Array.isArray(item)) throw "Multi-dimensional arrays not supported (for: ".concat(tag, ")"); // if function try to evaluate, but must eventually return object or primitive

        var b = 0;

        while (typeof item === "function" && ++b <= 20) {
          item = item.call(context);
        }

        var itemRendered;

        switch (_typeof(item)) {
          case "object":
            // if an object literal, treat like a new render
            if ("_display" in item && !item._display) break;
            item._parent = context;
            itemRendered = _this2.__renderFunctionContext(template, tag, item);
            itemRendered = _this2.__render(itemRendered, item, tag);
            delete item._parent;
            break;

          default:
            // try to print value as is for flat values in array
            itemRendered = _this2.__renderValue(template, "".concat(tag, "."), item);
        }

        rendered += itemRendered;
      });
      return rendered;
    };

    return this.__renderSectionAbstract(html, tag, "#", render);
  };

  this.__renderFunctionContext = function (html, tag, context) {
    var _this3 = this;

    var opts = {
      split: ["~", "::"]
    },
        find = helpers.findTag(html, this.__delimiters, tag, opts),
        value,
        directives;

    while (find) {
      value = "";
      directives = find.directives; // must have at least the one split directive for function call

      if (directives.length) {
        var funcPath = find.directives[0],
            format = find.directives.length > 1 ? find.directives[1] : false;

        try {
          (function () {
            // search for function from root
            var path = funcPath.split("."),
                func = _this3.__data.root;
            path.forEach(function (sub, i) {
              func = func[path[i]] || func["~" + path[i]];
            });
            value = helpers.format(func.call(context), format);
          })();
        } catch (e) {
          if (this.errorOnFuncFailure) throw e;
          console.error(e);
          value = "";
        }

        html = html.slice(0, find.start) + value + html.slice(find.end);
        opts.search = find.start + value.length;
      } else {
        opts.search = find.end;
      }

      find = helpers.findTag(html, this.__delimiters, tag, opts);
    }

    return html;
  };
};

var Templatize = {};
templatize_Interface.call(Templatize);

Templatize.custom = function (options) {
  return templatize_Interface(options);
};

/* harmony default export */ var templatize = __webpack_exports__["default"] = (Templatize);

/***/ })
/******/ ])["default"];
});