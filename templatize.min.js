(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["Templatize"] = factory();
	else
		root["Templatize"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// CONCATENATED MODULE: ./lib/directives.js
var DIRECTIVES = {
  TO_SYMBOL: {},
  TO_VALUE: {}
};
var SYMBOLS = {
  COMMENT: "!",
  LIST: "&",
  SECTION_INC: "#",
  SECTION_EXC: "^",
  SECTION_END: "/",
  PARTIALS: ">",
  ROOT_PARTIAL: "^",
  IN_CONTEXT: ".",
  PASS_CONTEXT: "->",
  FORMAT: "::",
  ESCAPE: ";"
};
var directives_i = 0;

for (var directives_name in SYMBOLS) {
  DIRECTIVES[directives_name] = ++directives_i;
  DIRECTIVES.TO_SYMBOL[directives_i] = SYMBOLS[directives_name];
  DIRECTIVES.TO_VALUE[SYMBOLS[directives_name]] = directives_i;
}

/* harmony default export */ var directives = (DIRECTIVES);
// CONCATENATED MODULE: ./lib/nodes.js
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }



var Node = /*#__PURE__*/function () {
  function Node(key) {
    _classCallCheck(this, Node);

    this.key = key || "";
    this.keysplit = [];
  }

  _createClass(Node, [{
    key: "_finish",
    value: function _finish() {
      this.keysplit = this.key.split(".");
    }
  }]);

  return Node;
}();

var RootNode = /*#__PURE__*/function (_Node) {
  _inherits(RootNode, _Node);

  var _super = _createSuper(RootNode);

  function RootNode() {
    var _this;

    _classCallCheck(this, RootNode);

    _this = _super.call(this);
    _this.inner = [];
    return _this;
  }

  return RootNode;
}(Node);

var TextNode = /*#__PURE__*/function (_Node2) {
  _inherits(TextNode, _Node2);

  var _super2 = _createSuper(TextNode);

  function TextNode(text) {
    var _this2;

    _classCallCheck(this, TextNode);

    _this2 = _super2.call(this);
    _this2.text = text;
    return _this2;
  }

  return TextNode;
}(Node);

var nodes_TagNode = /*#__PURE__*/function (_Node3) {
  _inherits(TagNode, _Node3);

  var _super3 = _createSuper(TagNode);

  function TagNode(raw, inner) {
    var _this3;

    _classCallCheck(this, TagNode);

    _this3 = _super3.call(this);
    _this3.raw = raw;
    _this3.inner = inner.trim();
    _this3.directive = 0;
    _this3.incontext = false;
    _this3.func = null;
    _this3.format = "";
    _this3.escape = false; // ignore empties (by marking as comment)

    if (!_this3.inner.length) {
      _this3.directive = directives.COMMENT;
    } else {
      _this3.key = _this3.inner; // leading directive

      _this3.directive = directives.TO_VALUE[_this3.inner[0]];

      if (!_this3.directive) {
        _this3.directive = 0;
      } else {
        switch (_this3.directive) {
          case directives.IN_CONTEXT: // handled separately as can be doubled-up

          case directives.PASS_CONTEXT: // here and below are not leading directives

          case directives.FORMAT:
          case directives.ESCAPE:
            _this3.directive = 0;
            break;

          case directives.ROOT_PARTIAL:
            // this one doubles as exclusive section so special case
            _this3.directive = directives.SECTION_EXC;

          default:
            _this3.key = _this3.key.slice(1);
        }
      } // check for in-context-directive


      if (_this3.key[0] === directives.TO_SYMBOL[directives.IN_CONTEXT]) {
        _this3.incontext = true;
        _this3.key = _this3.key.slice(1);
      }

      if (_this3.directive === directives.PARTIAL && _this3.incontext) {
        throw "Invalid tag: cannot have partial directive as in-context at ".concat(_this3.raw);
      } // context directive


      var sym, split;
      sym = directives.TO_SYMBOL[directives.PASS_CONTEXT];
      split = _this3.key.split(sym); // note pure context tag {{.}} can be split with empty first {{.~tofunc}}

      if (split.length > 1) {
        if (split.length > 2) {
          throw "Invalid tag: multiple function context directives at ".concat(_this3.raw);
        }

        if (!split[0] && !_this3.incontext || !split[1] || split[1][0] === sym[0]) {
          throw "Invalid tag: malformatted function context directive at ".concat(_this3.raw);
        }

        _this3.key = split[0];
        _this3.func = split[1];
      } // format directive


      sym = directives.TO_SYMBOL[directives.FORMAT];
      split = (_this3.func || _this3.key).split(sym); // leading or ending with format directive, assume part of name

      if (split.length === 2) {
        if (!split[0] && !_this3.incontext) {
          split = [split[1]];
        } else if (!split[1]) {
          split = [split[0]];
        }
      }

      if (split.length > 1) {
        if (split.length > 2) {
          throw "Invalid tag: multiple format directives at ".concat(_this3.raw);
        }

        if (!split[0] && !_this3.incontext || !split[1] || split[1][0] === sym[0]) {
          throw "Invalid tag: malformatted format directive at ".concat(_this3.raw);
        }

        _this3.format = split[1];

        if (_this3.func) {
          _this3.func = split[0];
        } else {
          _this3.key = split[0];
        }
      } // escape directive


      sym = directives.TO_SYMBOL[directives.ESCAPE];
      split = _this3.func || _this3.key;

      if (split.endsWith(sym)) {
        _this3.escape = true;
        split = split.slice(0, -1);

        if (_this3.func) {
          _this3.func = split;
        } else {
          _this3.key = split;
        }
      }

      if (_this3.format.endsWith(sym)) {
        _this3.escape = true;
        _this3.format = _this3.format.slice(0, -1);
      } // convert pass-to-function key to node


      if (_this3.func) _this3.func = new nodes_PassToFunctionNode(_this3.func, _assertThisInitialized(_this3));
    } // final key check


    _this3.key = _this3.key.trim();

    if (!_this3.key.length && !_this3.incontext) {
      // can't be empty except special case for pure context {{.}}
      throw "Invalid tag: empty evaluation at ".concat(_this3.raw);
    } // this fills keysplit


    _this3._finish();

    return _this3;
  }

  return TagNode;
}(Node);

;

var nodes_PassToFunctionNode = /*#__PURE__*/function (_Node4) {
  _inherits(PassToFunctionNode, _Node4);

  var _super4 = _createSuper(PassToFunctionNode);

  function PassToFunctionNode(key, contextNode) {
    var _this4;

    _classCallCheck(this, PassToFunctionNode);

    if (key instanceof PassToFunctionNode) {
      _this4 = _super4.call(this, key.key);
      _this4.incontext = key.incontext;
    } else {
      _this4 = _super4.call(this, key);
      _this4.incontext = false; // function can have context directive, but can't be pure context -- e.g. {{data~.}}

      if (_this4.key[0] === directives.TO_SYMBOL[directives.IN_CONTEXT]) {
        _this4.key = _this4.key.slice(1);
        _this4.incontext = true;
      }

      if (!_this4.key.length && !_this4.incontext) throw "Invalid tag: empty evaluation at ".concat(contextNode.raw);
    }

    _this4._finish();

    return _possibleConstructorReturn(_this4);
  }

  return PassToFunctionNode;
}(Node);

;

var nodes_PartialNode = /*#__PURE__*/function (_Node5) {
  _inherits(PartialNode, _Node5);

  var _super5 = _createSuper(PartialNode);

  function PartialNode(tag) {
    var _this5;

    _classCallCheck(this, PartialNode);

    _this5 = _super5.call(this);
    if (tag.incontext) throw "Partial tag cannot be paired with in-context directive at ".concat(tag.raw);
    if (tag.format) throw "Partial tag cannot be paired with format directive at ".concat(tag.raw);
    if (tag.escape) throw "Partial tag cannot be paired with escape directive at ".concat(tag.raw);
    if (tag.func) throw "Partial tag cannot be paired with pass-to-function directive at ".concat(tag.raw);
    _this5.directive = directives.PARTIAL;
    _this5.raw = tag.raw;
    _this5.inner = tag.inner;
    _this5.key = tag.key;
    _this5.incontext = true; // partials default to in-context

    if (_this5.key.endsWith(directives.TO_SYMBOL[directives.ROOT_PARTIAL])) {
      _this5.key = _this5.key.slice(0, -1);
      _this5.incontext = false;
      if (!_this5.key.length) throw "Empty partial tag at ".concat(tag.raw);
    }

    _this5._finish();

    return _this5;
  }

  return PartialNode;
}(Node);

;

var nodes_SectionNode = /*#__PURE__*/function (_Node6) {
  _inherits(SectionNode, _Node6);

  var _super6 = _createSuper(SectionNode);

  function SectionNode(tag, parent) {
    var _this6;

    _classCallCheck(this, SectionNode);

    _this6 = _super6.call(this, tag.key);
    _this6.raw = tag.raw;
    _this6.inner = [];
    _this6.incontext = tag.incontext;
    _this6.parent = parent;

    if (tag instanceof SectionNode) {
      _this6.func = tag.func ? new nodes_PassToFunctionNode(tag.func) : null;
      _this6.inclusive = tag.inclusive;
      _this6.open = tag.open;
      _this6.close = tag.close;
    } else {
      _this6.func = tag.func;
      _this6.inclusive = Boolean(tag.directive === directives.SECTION_INC);
      _this6.open = tag;
      _this6.close = null;
      if (tag.format) throw "Invalid tag: format passed to section tag ".concat(tag.raw);
      if (tag.escape) throw "Invalid tag: escape directive passed to section tag ".concat(tag.raw);

      if (tag.directive !== directives.SECTION_INC && tag.directive !== directives.SECTION_EXC) {
        throw "Template error: parsing invalid section tag ".concat(tag.raw);
      }
    }

    _this6._finish();

    return _this6;
  }

  return SectionNode;
}(Node);


// CONCATENATED MODULE: ./node_modules/d3-format/src/formatDecimal.js
/* harmony default export */ var formatDecimal = (function(x) {
  return Math.abs(x = Math.round(x)) >= 1e21
      ? x.toLocaleString("en").replace(/,/g, "")
      : x.toString(10);
});

// Computes the decimal coefficient and exponent of the specified number x with
// significant digits p, where x is positive and p is in [1, 21] or undefined.
// For example, formatDecimalParts(1.23) returns ["123", 0].
function formatDecimalParts(x, p) {
  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, ±Infinity
  var i, coefficient = x.slice(0, i);

  // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
  // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x.slice(i + 1)
  ];
}

// CONCATENATED MODULE: ./node_modules/d3-format/src/exponent.js


/* harmony default export */ var src_exponent = (function(x) {
  return x = formatDecimalParts(Math.abs(x)), x ? x[1] : NaN;
});

// CONCATENATED MODULE: ./node_modules/d3-format/src/formatGroup.js
/* harmony default export */ var formatGroup = (function(grouping, thousands) {
  return function(value, width) {
    var i = value.length,
        t = [],
        j = 0,
        g = grouping[0],
        length = 0;

    while (i > 0 && g > 0) {
      if (length + g + 1 > width) g = Math.max(1, width - length);
      t.push(value.substring(i -= g, i + g));
      if ((length += g + 1) > width) break;
      g = grouping[j = (j + 1) % grouping.length];
    }

    return t.reverse().join(thousands);
  };
});

// CONCATENATED MODULE: ./node_modules/d3-format/src/formatNumerals.js
/* harmony default export */ var formatNumerals = (function(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
});

// CONCATENATED MODULE: ./node_modules/d3-format/src/formatSpecifier.js
// [[fill]align][sign][symbol][0][width][,][.precision][~][type]
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;

function formatSpecifier(specifier) {
  if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
  var match;
  return new FormatSpecifier({
    fill: match[1],
    align: match[2],
    sign: match[3],
    symbol: match[4],
    zero: match[5],
    width: match[6],
    comma: match[7],
    precision: match[8] && match[8].slice(1),
    trim: match[9],
    type: match[10]
  });
}

formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof

function FormatSpecifier(specifier) {
  this.fill = specifier.fill === undefined ? " " : specifier.fill + "";
  this.align = specifier.align === undefined ? ">" : specifier.align + "";
  this.sign = specifier.sign === undefined ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === undefined ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === undefined ? undefined : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === undefined ? undefined : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === undefined ? "" : specifier.type + "";
}

FormatSpecifier.prototype.toString = function() {
  return this.fill
      + this.align
      + this.sign
      + this.symbol
      + (this.zero ? "0" : "")
      + (this.width === undefined ? "" : Math.max(1, this.width | 0))
      + (this.comma ? "," : "")
      + (this.precision === undefined ? "" : "." + Math.max(0, this.precision | 0))
      + (this.trim ? "~" : "")
      + this.type;
};

// CONCATENATED MODULE: ./node_modules/d3-format/src/formatTrim.js
// Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.
/* harmony default export */ var formatTrim = (function(s) {
  out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
    switch (s[i]) {
      case ".": i0 = i1 = i; break;
      case "0": if (i0 === 0) i0 = i; i1 = i; break;
      default: if (!+s[i]) break out; if (i0 > 0) i0 = 0; break;
    }
  }
  return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
});

// CONCATENATED MODULE: ./node_modules/d3-format/src/formatPrefixAuto.js


var prefixExponent;

/* harmony default export */ var formatPrefixAuto = (function(x, p) {
  var d = formatDecimalParts(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1],
      i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
      n = coefficient.length;
  return i === n ? coefficient
      : i > n ? coefficient + new Array(i - n + 1).join("0")
      : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
      : "0." + new Array(1 - i).join("0") + formatDecimalParts(x, Math.max(0, p + i - 1))[0]; // less than 1y!
});

// CONCATENATED MODULE: ./node_modules/d3-format/src/formatRounded.js


/* harmony default export */ var formatRounded = (function(x, p) {
  var d = formatDecimalParts(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
      : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
      : coefficient + new Array(exponent - coefficient.length + 2).join("0");
});

// CONCATENATED MODULE: ./node_modules/d3-format/src/formatTypes.js




/* harmony default export */ var formatTypes = ({
  "%": (x, p) => (x * 100).toFixed(p),
  "b": (x) => Math.round(x).toString(2),
  "c": (x) => x + "",
  "d": formatDecimal,
  "e": (x, p) => x.toExponential(p),
  "f": (x, p) => x.toFixed(p),
  "g": (x, p) => x.toPrecision(p),
  "o": (x) => Math.round(x).toString(8),
  "p": (x, p) => formatRounded(x * 100, p),
  "r": formatRounded,
  "s": formatPrefixAuto,
  "X": (x) => Math.round(x).toString(16).toUpperCase(),
  "x": (x) => Math.round(x).toString(16)
});

// CONCATENATED MODULE: ./node_modules/d3-format/src/identity.js
/* harmony default export */ var identity = (function(x) {
  return x;
});

// CONCATENATED MODULE: ./node_modules/d3-format/src/locale.js









var map = Array.prototype.map,
    prefixes = ["y","z","a","f","p","n","µ","m","","k","M","G","T","P","E","Z","Y"];

/* harmony default export */ var src_locale = (function(locale) {
  var group = locale.grouping === undefined || locale.thousands === undefined ? identity : formatGroup(map.call(locale.grouping, Number), locale.thousands + ""),
      currencyPrefix = locale.currency === undefined ? "" : locale.currency[0] + "",
      currencySuffix = locale.currency === undefined ? "" : locale.currency[1] + "",
      decimal = locale.decimal === undefined ? "." : locale.decimal + "",
      numerals = locale.numerals === undefined ? identity : formatNumerals(map.call(locale.numerals, String)),
      percent = locale.percent === undefined ? "%" : locale.percent + "",
      minus = locale.minus === undefined ? "−" : locale.minus + "",
      nan = locale.nan === undefined ? "NaN" : locale.nan + "";

  function newFormat(specifier) {
    specifier = formatSpecifier(specifier);

    var fill = specifier.fill,
        align = specifier.align,
        sign = specifier.sign,
        symbol = specifier.symbol,
        zero = specifier.zero,
        width = specifier.width,
        comma = specifier.comma,
        precision = specifier.precision,
        trim = specifier.trim,
        type = specifier.type;

    // The "n" type is an alias for ",g".
    if (type === "n") comma = true, type = "g";

    // The "" type, and any invalid type, is an alias for ".12~g".
    else if (!formatTypes[type]) precision === undefined && (precision = 12), trim = true, type = "g";

    // If zero fill is specified, padding goes after sign and before digits.
    if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";

    // Compute the prefix and suffix.
    // For SI-prefix, the suffix is lazily computed.
    var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
        suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";

    // What format function should we use?
    // Is this an integer type?
    // Can this type generate exponential notation?
    var formatType = formatTypes[type],
        maybeSuffix = /[defgprs%]/.test(type);

    // Set the default precision if not specified,
    // or clamp the specified precision to the supported range.
    // For significant precision, it must be in [1, 21].
    // For fixed precision, it must be in [0, 20].
    precision = precision === undefined ? 6
        : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
        : Math.max(0, Math.min(20, precision));

    function format(value) {
      var valuePrefix = prefix,
          valueSuffix = suffix,
          i, n, c;

      if (type === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;

        // Determine the sign. -0 is not less than 0, but 1 / -0 is!
        var valueNegative = value < 0 || 1 / value < 0;

        // Perform the initial formatting.
        value = isNaN(value) ? nan : formatType(Math.abs(value), precision);

        // Trim insignificant zeros.
        if (trim) value = formatTrim(value);

        // If a negative value rounds to zero after formatting, and no explicit positive sign is requested, hide the sign.
        if (valueNegative && +value === 0 && sign !== "+") valueNegative = false;

        // Compute the prefix and suffix.
        valuePrefix = (valueNegative ? (sign === "(" ? sign : minus) : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
        valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");

        // Break the formatted value into the integer “value” part that can be
        // grouped, and fractional or exponential “suffix” part that is not.
        if (maybeSuffix) {
          i = -1, n = value.length;
          while (++i < n) {
            if (c = value.charCodeAt(i), 48 > c || c > 57) {
              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
              value = value.slice(0, i);
              break;
            }
          }
        }
      }

      // If the fill character is not "0", grouping is applied before padding.
      if (comma && !zero) value = group(value, Infinity);

      // Compute the padding.
      var length = valuePrefix.length + value.length + valueSuffix.length,
          padding = length < width ? new Array(width - length + 1).join(fill) : "";

      // If the fill character is "0", grouping is applied after padding.
      if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

      // Reconstruct the final output based on the desired alignment.
      switch (align) {
        case "<": value = valuePrefix + value + valueSuffix + padding; break;
        case "=": value = valuePrefix + padding + value + valueSuffix; break;
        case "^": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;
        default: value = padding + valuePrefix + value + valueSuffix; break;
      }

      return numerals(value);
    }

    format.toString = function() {
      return specifier + "";
    };

    return format;
  }

  function formatPrefix(specifier, value) {
    var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)),
        e = Math.max(-8, Math.min(8, Math.floor(src_exponent(value) / 3))) * 3,
        k = Math.pow(10, -e),
        prefix = prefixes[8 + e / 3];
    return function(value) {
      return f(k * value) + prefix;
    };
  }

  return {
    format: newFormat,
    formatPrefix: formatPrefix
  };
});

// CONCATENATED MODULE: ./node_modules/d3-format/src/defaultLocale.js


var defaultLocale_locale;
var defaultLocale_format;
var defaultLocale_formatPrefix;

defaultLocale({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});

function defaultLocale(definition) {
  defaultLocale_locale = src_locale(definition);
  defaultLocale_format = defaultLocale_locale.format;
  defaultLocale_formatPrefix = defaultLocale_locale.formatPrefix;
  return defaultLocale_locale;
}

// CONCATENATED MODULE: ./lib/misc.js
function misc_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { misc_typeof = function _typeof(obj) { return typeof obj; }; } else { misc_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return misc_typeof(obj); }


var OVERFLOW = 12;
var TYPES = {
  UNDEFINED: -1,
  NULL: 0,
  VALUE: 1,
  STRING: 1,
  NUMBER: 1,
  ARRAY: 2,
  OBJECT: 3,
  FUNCTION: 4
};

function typeOf(value) {
  switch (value) {
    case undefined:
      return TYPES.UNDEFINED;

    case null:
      return TYPES.NULL;
  }

  if (Array.isArray(value)) return TYPES.ARRAY;

  switch (misc_typeof(value)) {
    case "object":
      return TYPES.OBJECT;

    case "function":
      return TYPES.FUNCTION;
  }

  return TYPES.VALUE;
}

;

function evalf(func, context, root, handleException) {
  context = context || {};

  try {
    var value = func,
        i = 0;

    while (typeof value === "function") {
      if (++i >= OVERFLOW) break;
      value = value.call(context, root);
    }

    return value;
  } catch (e) {
    if (handleException) {
      return handleException(e);
    } else {
      throw e;
    }
  }
}

;

function formatValue(value, format, escapehtml) {
  if (!value && value !== 0) return "";
  value = value.toString();

  if (format) {
    switch (format) {
      case "raw":
      case "html":
        escapehtml = false;
        break;

      case "encode":
        escapehtml = true;
        break;

      case "allcaps":
      case "caps":
      case "upper":
        value = value.toUpperCase();
        break;

      case "lower":
        value = value.toLowerCase();
        break;

      case "capitalize":
        value = value.replace(/(?:^|[^\w])[a-z]/g, function (match) {
          return match === "'s" ? match : match.toUpperCase();
        });
        break;

      default:
        try {
          if (format) value = defaultLocale_format(format)(value);
        } catch (e) {
          console.error("Render error: unrecognized/bad format value \"".concat(format, "\""));
        }

    }
  }

  if (escapehtml) {
    value = value.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
  }

  return value;
}

;

// CONCATENATED MODULE: ./lib/template.js
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function template_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function template_createClass(Constructor, protoProps, staticProps) { if (protoProps) template_defineProperties(Constructor.prototype, protoProps); if (staticProps) template_defineProperties(Constructor, staticProps); return Constructor; }

function template_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }




var Tag = function Tag(key) {
  template_classCallCheck(this, Tag);

  this.key = key;
};

var DEFAULT = {
  delimiters: ["{{", "}}"]
};

var template_Template = /*#__PURE__*/function () {
  function Template(template, options) {
    template_classCallCheck(this, Template);

    this.delimiters;
    this.template = template;
    this.root = new RootNode();
    this.parse(options && options.delimiters || DEFAULT.delimiters);
  }

  template_createClass(Template, [{
    key: "parse",
    value: function parse(delimiters) {
      this.delimiters = _toConsumableArray(delimiters);
      var template = this.template,
          last = 0,
          search = 0,
          open = -1,
          start = -1,
          close = -1,
          current = this.root,
          nest = 0,
          raw,
          node;

      while (true) {
        // find opening delimiter
        open = template.indexOf(delimiters[0], search);
        if (!~open) break;
        start = open + delimiters[0].length; // find closing delimiter

        close = template.indexOf(delimiters[1], search);
        if (!~close) break; // update search position

        search = close + delimiters[1].length; // ignore escaped (remove directive character in template)

        if (template[open - 1] === "!") {
          template = template.slice(0, open - 1) + template.slice(open);
          search -= 1;
          continue;
        } // grab preceding content


        if (open && open > last) {
          current.inner.push(new TextNode(template.slice(last, open)));
        }

        last = search; // create node and handle

        node = new nodes_TagNode(template.slice(open, search), template.slice(start, close).trim());

        switch (node.directive) {
          // ignore comments
          case directives.COMMENT:
            break;
          // convert partials

          case directives.PARTIAL:
            node = new nodes_PartialNode(node);
            current.inner.push(node);
            break;
          // handle sections

          case directives.SECTION_END:
            if (current instanceof RootNode) throw "Invalid template: unpaired section close at ".concat(node.raw);
            if (current.open.key !== node.key) throw "Invalid template: Invalid template: section conflict at ".concat(node.raw, " close before inner ").concat(current.open.raw, " closed"); //current.close = node;

            current = current.parent;
            --nest;
            break;

          case directives.SECTION_INC:
          case directives.SECTION_EXC:
            var section = new nodes_SectionNode(node, current);
            current.inner.push(section);
            current = section;
            ++nest;
            break;
          // all others check if in context

          default:
            if (!node.incontext) {}

            current.inner.push(node);
            break;
        }
      } // push last text


      if (last < template.length) {
        current.inner.push(new TextNode(template.slice(search, template.length)));
      } // final error check


      if (current !== this.root) throw "Invalid template: hanging open section for ".concat(current.open.raw);
    }
  }]);

  return Template;
}();

;
/* harmony default export */ var lib_template = (template_Template);
// CONCATENATED MODULE: ./lib/domain.js
function domain_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function domain_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function domain_createClass(Constructor, protoProps, staticProps) { if (protoProps) domain_defineProperties(Constructor.prototype, protoProps); if (staticProps) domain_defineProperties(Constructor, staticProps); return Constructor; }




var domain_Domain = /*#__PURE__*/function () {
  function Domain(data, fullkey, parent, handleMissing) {
    domain_classCallCheck(this, Domain);

    this.fullkey = fullkey || "";
    this.prefix = this.fullkey ? this.fullkey + "." : this.fullkey;
    this.data = data;
    this["function"] = null;
    this.type = typeOf(this.data);
    this.parent = parent || null;
    this.root = this.parent && this.parent.root || this;
    this.handleMissing = handleMissing || this.parent && this.parent.handleMissing || "throw";
    this.cache = parent && parent.cache || {};
    this.children = {
      ".": this
    };
    this.isrepeating = false;
    this.dynamic = {
      children: {},
      length: this.lengthDynamic.bind(this),
      'get': this.getDynamic.bind(this),
      create: this.createDynamic.bind(this)
    };

    switch (this.type) {
      // object parent reference
      case TYPES.OBJECT:
        this.data._parent = this.parent && this.parent.data || null;
        break;
      // function store reference to function, data is f() output but resolved whenever first called

      case TYPES.FUNCTION:
        this["function"] = this.data;
        this.data = null;
        break;
      // dynamic data that changes based on context (e.g. an array where items iterated with same tags)

      case TYPES.ARRAY:
        this.isrepeating = true;
        break;
    }
  }

  domain_createClass(Domain, [{
    key: "killAllParents",
    value: function killAllParents() {
      var child;

      for (var key in this.children) {
        child = this.children[key];

        if (child !== this && child.type === TYPES.OBJECT) {
          delete child.data.parent;
          child.cleanup();
        }
      }

      for (var _key in this.dynamic.children) {
        child = this.dynamic.children[_key];

        if (child !== this && child.type === TYPES.OBJECT) {
          delete child.data.parent;
          child.cleanup();
        }
      }
    }
  }, {
    key: "cleanup",
    value: function cleanup() {
      this.killAllParents();
    } // missing value handler

  }, {
    key: "missing",
    value: function missing(key, handleMissing) {
      switch (handleMissing || this.handleMissing) {
        case "throw":
        case "error":
          throw "Render error: missing binding for '".concat(key, "'");

        case "null":
          return null;

        default:
          return "";
          break;
      }
    }
  }, {
    key: "_eval",
    value: function _eval(onFuncError) {
      if (this["function"] && !this.data) {
        this.data = evalf(this["function"], this.parent.data, this.root.data);
        this.type = typeOf(this.data);

        if (this.type === TYPES.ARRAY) {
          this.isrepeating = true;
        } else {
          this.cache[this.fullkey] = this;
        }
      }

      return this.data;
    }
    /* 
     * Get raw value (assumed called when already in inner-most context). For functions uses evaluated value.
     */

  }, {
    key: "value",
    value: function value(onFuncError) {
      return this._eval(onFuncError);
    }
    /* 
     * Get child data domain / subcontext. If function and first time, evaluates function till non-function 
     * type and changes type. If called in dynamic domain, return null.
     */

  }, {
    key: "get",
    value: function get(key, onFuncError, skipCache) {
      var fullkey;

      if (key && key !== ".") {
        fullkey = this.prefix + key;
      } else {
        fullkey = this.fullkey;
        key = ".";
      } // functions render on first handle to resolve what data is


      this._eval(onFuncError); // check cache


      if (!skipCache && fullkey in this.cache) return this.cache[fullkey]; // can't normal 'get' children of repeating sections (use getDynamic)

      if (this.isrepeating) return null; // get context or create if not yet existing

      if (key in this.children) return this.children[key];
      if (!(key in this.data)) return null;
      var subcontext = new Domain(this.data[key], fullkey, this);
      this.children[key] = this.cache[fullkey] = subcontext;
      return subcontext;
    }
    /* 
     * Get dynamic length.
     */

  }, {
    key: "lengthDynamic",
    value: function lengthDynamic() {
      switch (this.type) {
        case TYPES.ARRAY:
          return this.data.length;

        case TYPES.NULL:
        case TYPES.UNDEFINED:
          return 0;
      }

      return 1;
    }
    /*
     * Get dynamic data domain by index. Used for repeating sections to dynamically load the domain of an 
     * array item. If not an array-type, simply loads the current data.
     * 
     * Dynamic data domain acts as if in the same location as this domain (with same key and parent), but with
     * dynamic data that is different. Note that if search up to parent and back down, however, it cannot be 
     * re-found with same key. It is technically stored as a dynamic child of this domain.
     */

  }, {
    key: "getDynamic",
    value: function getDynamic(index, context, onFuncError) {
      var dykey = "<".concat(index, ">"),
          dydata = this.isrepeating ? this.data[index] : this._eval(onFuncError); // get context or create if not yet existing

      if (dykey in this.dynamic.children) return this.dynamic.children[dykey];
      context = new Domain(dydata, this.fullkey, this.parent);
      context.cache = {}; // disconnect cache for dynamic contexts

      this.dynamic.children[dykey] = context;
      return context;
    }
    /*
     * Get dynamic data domain with custom data. Must also supply unique key modifier.
     * 
     * Dynamic data domain acts as if in the same location as this domain (with same key and parent), but with
     * dynamic data that is different. Note that if search up to parent and back down, however, it cannot be 
     * re-found with same key. It is technically stored as a dynamic child of this domain.
     */

  }, {
    key: "createDynamic",
    value: function createDynamic(dkey, withData) {
      var dykey = "<0:".concat(dkey, ">"); // if context exists in children, clear existing first

      if (dykey in this.dynamic.children) this.dynamic.children[dykey].cleanup(); // create context

      var context = new Domain(withData, this.fullkey, this.parent);
      context.cache = {}; // disconnect cache for dynamic contexts

      this.dynamic.children[dykey] = context;
      return context;
    }
    /* 
     * Check if node is in this context (lazy search, doesn't check if most specific).
     */

  }, {
    key: "incontext",
    value: function incontext(fullKeyOrNode) {
      var key = fullKeyOrNode;

      if (fullKeyOrNode instanceof Node) {
        if (fullKeyOrNode.incontext) return true;
        key = fullKeyOrNode.key;
      }

      return key === this.fullkey || key.startsWith(this.prefix);
    }
    /* 
     * Search for domain.
     */

  }, {
    key: "_search",
    value: function _search(fullkey, keysplit, onFuncError, bubble, atstart) {
      // if start of search, try cache
      if (atstart && fullkey in this.cache) {
        return this.cache[fullkey];
      } // if exactly at, return self


      if (!keysplit.length || this.fullkey === fullkey) return this;

      if (bubble) {
        // reverse search condition when in context or at root (can always bubble out of dynamic domain)
        if (!this.parent) {
          return this._search(fullkey, keysplit, onFuncError);
        } else if (this.incontext(fullkey)) {
          var i = -1;

          while (++i < keysplit.length && this.prefix.startsWith(keysplit[i] + ".")) {// all handled in loop condition
          }

          if (i && i < keysplit.length) keysplit = keysplit.slice(i);
          return this._search(fullkey, keysplit, onFuncError);
        } // continue bubbling (if exiting dynamic, reset 'atstart' to try parent's cache)


        return this.parent._search(fullkey, keysplit, onFuncError, true, this.isrepeating);
      } // to handle names with periods in them (user-error by try to work with), append key parts till match


      var subcontext,
          key = "";

      for (var k = 0; k < keysplit.length; ++k) {
        key += keysplit[k];
        subcontext = this.get(key, onFuncError, true);

        if (subcontext) {
          if (subcontext === this) break; // special case when key="."

          return subcontext._search(fullkey, keysplit.slice(k + 1), onFuncError);
        }

        key += ".";
      }

      return keysplit.length ? null : this;
    }
  }, {
    key: "search",
    value: function search(node, onFuncError) {
      // special case for {{.}}
      if (!node.key && node.incontext) return this; // try cache with full keys (note in-context nodes skip bubble)

      return this._search(node.key, node.keysplit, onFuncError, !node.incontext, true);
    }
  }, {
    key: "context",
    value: function context(node, onFuncError) {
      return this.search(node);
    }
  }, {
    key: "from",
    value: function from(node, onFuncError) {
      return this.search(node);
    }
  }]);

  return Domain;
}();

/* harmony default export */ var lib_domain = (domain_Domain);
// CONCATENATED MODULE: ./lib/interface.js
function interface_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { interface_typeof = function _typeof(obj) { return typeof obj; }; } else { interface_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return interface_typeof(obj); }

function interface_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function interface_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function interface_createClass(Constructor, protoProps, staticProps) { if (protoProps) interface_defineProperties(Constructor.prototype, protoProps); if (staticProps) interface_defineProperties(Constructor, staticProps); return Constructor; }






var interface_DEFAULT = {
  errorOnFuncFailure: false,
  evalZeroAsTrue: false,
  escapeAll: false,
  errorOnMissingTags: false
};

var interface_Interface = /*#__PURE__*/function () {
  function Interface(template, options) {
    interface_classCallCheck(this, Interface);

    options = options || {};
    this._errorOnFuncFailure = options.errorOnFuncFailure || interface_DEFAULT.errorOnFuncFailure;
    this._evalZeroAsTrue = options.evalZeroAsTrue || interface_DEFAULT.evalZeroAsTrue;
    this._escapeAll = options.escapeAll || interface_DEFAULT.escapeAll;
    this._errorOnMissingTags = options.errorOnMissingTags || interface_DEFAULT.errorOnMissingTags;
    this._template = template; // this._bindings           = null;

    this._root = null;
    this._partials = {};
    this._options = {};
    this._errorHandler = null;
  }

  interface_createClass(Interface, [{
    key: "errorOnFuncFailure",
    get: function get() {
      return this._errorOnFuncFailure;
    },
    set: function set(to) {
      if (typeof to !== "undefined") this._errorOnFuncFailure = Boolean(to);
    }
  }, {
    key: "evalZeroAsTrue",
    get: function get() {
      return this._evalZeroAsTrue;
    },
    set: function set(to) {
      if (typeof to !== "undefined") this._evalZeroAsTrue = Boolean(to);
    }
  }, {
    key: "escapeAll",
    get: function get() {
      return this._escapeAll;
    },
    set: function set(to) {
      if (typeof to !== "undefined") this._escapeAll = Boolean(to);
    }
  }, {
    key: "errorOnMissingTags",
    get: function get() {
      return this._errorOnMissingTags;
    },
    set: function set(to) {
      if (typeof to !== "undefined") this._errorOnMissingTags = Boolean(to);
    }
  }, {
    key: "_missingHandler",
    value: function _missingHandler(key, throwError) {
      if (throwError || this._errorOnMissingTags) {
        throw "Render error: missing binding for '".concat(key, "'");
      }

      ;
      return "";
    }
  }, {
    key: "render",
    value: function render(bindings, options) {
      options = options || {};
      if (options.errorOnFuncFailure !== undefined) this.errorOnFuncFailure = options.errorOnFuncFailure;
      if (options.evalZeroAsTrue !== undefined) this.evalZeroAsTrue = options.evalZeroAsTrue;
      if (options.escapeAll !== undefined) this.escapeAll = options.escapeAll;
      if (options.handleMissingTags !== undefined) this.handleMissingTags = options.handleMissingTags;

      this._errorHandler = function (throwError) {
        return function (key) {
          return function (exception) {
            if (throwError) throw exception;
            console.error("Error evaluating bindings at ".concat(key));
            console.error(exception);
            return "";
          };
        };
      }(this._errorOnFuncFailure);

      try {
        // snapshot options
        this._options = {
          errorOnFuncFailure: this.errorOnFuncFailure,
          evalZeroAsTrue: this.evalZeroAsTrue,
          escapeAll: this.escapeAll,
          handleMissingTags: this.handleMissingTags
        };

        if (bindings instanceof lib_domain) {
          // partials get passed context object, don't need to recreate
          this._root = bindings;
        } else {
          this._root = new lib_domain(bindings);
        } // map partials


        this._partials = options.partials || {};

        for (var pkey in this._partials) {
          if (typeof this._partials[pkey] === "string") {
            try {
              this._partials[pkey] = new lib_template(this._partials[pkey]);
            } catch (e) {
              console.error("Invalid partial template for '".concat(pkey, "'"));
              throw e;
            }
          } else if (!(this._partials[pkey] instanceof lib_template)) {
            throw "Invalid partial: must be instance of Template or template string ('".concat(pkey, "' is ").concat(interface_typeof(this._partials[pkey]), ")");
          }
        }

        return this._renderInsideOut(this._renderOutsideIn(this._template.root));
      } finally {
        // clean up references and temporary variables
        if (this._root) this._root.cleanup();
        this._root = null;
        this._partials = {};
        this._options = {};
      }
    }
  }, {
    key: "_processContext",
    value: function _processContext(node, domain, dynamics) {
      var onFuncError = this._errorHandler(node.raw),
          result = {
        isdynamic: false,
        isrepeating: false,
        length: 0
      }; // search function first checks dynamic contexts, if they exist


      var search = function search(sNode) {
        if (!sNode.incontext && dynamics && dynamics.length) {
          for (var d = 0; d < dynamics.length; ++d) {
            if (dynamics[d].incontext(sNode)) {
              return dynamics[d].search(sNode, onFuncError);
            }
          }
        }

        return domain.search(sNode, onFuncError);
      }; // get domain of node


      result.node = search(node, onFuncError);
      if (!result.node) return null; // evaluate properties of value context

      result.isdynamic = result.isrepeating = result.node.isrepeating;
      result.length = result.node.dynamic.length();

      if (!node.func) {
        result.value = result.node.value(onFuncError);
      } else {
        // get domain of function
        result.func = search(node.func, onFuncError);
        result.isdynamic = true;
        if (!result.func) throw "Context passed to unresolved function at ".concat(node.raw);
        if (!result.func["function"]) throw "Context passed to non-function at ".concat(node.raw);
        result.value = evalf(result.func["function"], result.node.value(onFuncError), this._root.data, onFuncError); // reevaluate properties of value context

        if (Array.isArray(result.value)) {
          result.isrepeating = true;
          result.length = result.value.length;
        }
      }

      var self = this;

      result.getDomain = function () {
        return self._getDynamicDomain(this);
      };

      return result;
    }
  }, {
    key: "_getDynamicDomain",
    value: function _getDynamicDomain(context) {
      if (context.isrepeating) {
        if (context.func) return context.node.dynamic.create(context.func.fullkey, context.value);
        return context.node;
      }

      if (!context.isdynamic) return context.node;
      return context.node.dynamic.create(context.func.fullkey, context.value);
    }
    /*
     * Rendering loop from the outside-in. Idea is to treat show/hide sections first this way to eliminate 
     * large chunks of hidden sections without wasting effort rendering what's inside.
     * 
     * Skips handling direct content for repeating sections, that's handled in _renderInsideOut(). However 
     * inner content referencing bindings not for repeating data should be handled. Tricky part is managing 
     * unresolved contexts as we parse through entire template.
     *
     * @param root       - The root data domain.
     * @param domain     - The current data domain.
     * @param processed  - Array of nodes to pass to return for next round of processing.
     * @param unresolved - Array of data domains in context that are unresolved (i.e. repeating).
     */

  }, {
    key: "_renderOutsideIn",
    value: function _renderOutsideIn(root, domain, processed, unresolved) {
      domain = domain || this._root;
      processed = processed || new RootNode();
      unresolved = unresolved || [];
      var node, context;

      for (var n = 0; n < root.inner.length; ++n) {
        node = root.inner[n]; // skip comments (shouldn't exist but just in case)

        if (node.directive === directives.COMMENT) continue; // text doesn't need processing

        if (node instanceof TextNode) {
          processed.inner.push(node);
          continue;
        } // render partial as sub-render with passed data domain and duplicate options


        if (node instanceof nodes_PartialNode) {
          processed.inner.push(this._partial(node, domain));
          continue;
        } // handling nodes in an unresolved context, some exceptions for sections and lists


        if (domain.isrepeating) {
          if (node.func && node.func.incontext || node.incontext) {
            processed.inner.push(node);
            continue;
          }
        }

        var forSection = node instanceof nodes_SectionNode,
            checkNode = !forSection && node.directive !== directives.LIST;

        if (unresolved.length && checkNode || node.func) {
          var cantResolve = false;

          for (var u = 0; u < unresolved.length; ++u) {
            if (checkNode && unresolved[u].incontext(node.key)) {
              cantResolve = true;
              break;
            }

            if (node.func && unresolved[u].incontext(node.func.key)) {
              cantResolve = true;
              break;
            }
          }

          if (cantResolve) {
            processed.inner.push(node);
            continue;
          }
        } // get data context -- if null, likely due to nesting into dynamic data, so defer processing


        context = this._processContext(node, domain);

        if (!context) {
          processed.inner.push(node);
          continue;
        } // render sections (handler split out, but basically recurses here)


        if (forSection) {
          this._section(node, context, processed, unresolved);

          continue;
        } // render straight values unless it depends on dynamic context (those defer till 2nd round)


        processed.inner.push(this._renderValue(node, context.value));
      }

      return processed;
    }
    /*
     * Rendering loop from the inside out. Idea is to rendering repeating sections from inner-most outwards to
     * avoid as much redundancy as possible. Only remaining tags should by repeating sections or tags 
     * dependent on the dynamic data domain inside a repeating section. So everything gets processed or is 
     * a missing data binding.
     */

  }, {
    key: "_renderInsideOut",
    value: function _renderInsideOut(root, domain, dynamics) {
      domain = domain || this._root;
      dynamics = dynamics || [];
      var node,
          context,
          useDomain,
          dydom,
          processed = new RootNode();

      for (var n = 0; n < root.inner.length; ++n) {
        node = root.inner[n]; // only handle sections for this first outside-in loop

        if (!(node instanceof nodes_SectionNode)) {
          processed.inner.push(node);
          continue;
        } // get context, missing here is either skip or exception thrown


        context = this._processContext(node, domain, dynamics);

        if (!context) {
          this._missingHandler(node.raw);

          continue;
        } // convert to dynamic domain, if necessary


        useDomain = context.getDomain(); // standard section bound to context within a dynamic data domain

        if (!context.isrepeating) {
          if (this._display(node.inclusive, useDomain)) {
            processed.inner.push(this._renderInsideOut(node, useDomain, dynamics));
          }

          continue;
        } // only thing left is repeating sections


        for (var i = 0; i < context.length; ++i) {
          dydom = useDomain.dynamic.get(i);
          dynamics.push(dydom);

          if (this._display(true, dydom)) {
            processed.inner.push(this._renderInsideOut(node, dydom, dynamics));
          }

          dynamics.pop();
        }
      } // this part will run from inner-most out on all remaining nodes


      var text = "";

      for (var _n = 0; _n < processed.inner.length; ++_n) {
        node = processed.inner[_n];

        if (node instanceof TextNode) {
          text += node.text;
        } else if (typeof node === "string") {
          text += node;
        } else {
          context = this._processContext(node, domain, dynamics);

          if (!context) {
            this._missingHandler(node.raw);
          } else {
            text += this._renderValue(node, context.value);
          }
        }
      }

      return text;
    }
  }, {
    key: "_section",
    value: function _section(node, context, processed, unresolved) {
      // Repeating sections recurse inner content to process any non-dynamic referencing tags, but also add 
      // node to processing array for final processing in inside-out rendering.
      if (context.isrepeating) {
        if (node.inclusive && context.length) {
          // Copy section node and replace any in-context shortcuts with full path as it will be handled
          // later, potentially out of context.
          var dynode = new nodes_SectionNode(node);

          if (dynode.incontext) {
            dynode.key = context.node.fullkey;
            dynode.incontext = false;

            dynode._finish();
          }

          if (dynode.func && dynode.func.incontext) {
            dynode.func.key = context.func.fullkey;
            dynode.func.incontext = false;

            dynode.func._finish();
          }

          var _domain = context.getDomain(); // Add to unresolved domains, recurse, pop unresolved domain, add to processing


          unresolved.push(_domain);

          this._renderOutsideIn(node, _domain, dynode, unresolved, true);

          unresolved.pop();
          processed.inner.push(dynode);
        }

        return;
      } // Standard sections simple recurse inner content to render. Only thing is checking for creation of 
      // dynamic data context first.


      var domain = this._getDynamicDomain(context);

      if (this._display(node.inclusive, domain)) {
        this._renderOutsideIn(node, domain, processed, unresolved);
      }
    }
  }, {
    key: "_display",
    value: function _display(inclusive, domain) {
      var display = domain.value();

      switch (domain.type) {
        case TYPES.OBJECT:
          var _display = domain.get("_display");

          if (_display) return _display.value();
          break;
        // Should only occur in edge case with multi-dimensional arrays in repeating section render as any
        // repeating section tag (which hinges display on array length) checks this separately. See above 
        // in _section(). Thus placeholder here that does nothing.

        case TYPES.ARRAY:
          break;

        default:
          switch (interface_typeof(display)) {
            case "string":
              display = display.trim();
              break;

            case "number":
              if (!display && display === 0) {
                display = this._evalZeroAsTrue;
              }

              break;
          }

          break;
      }

      return Boolean(inclusive) === Boolean(display);
    }
  }, {
    key: "_partial",
    value: function _partial(node, context) {
      if (!this._partials[node.key]) {
        switch (this._handleMissingTags) {
          case "throw":
          case "error":
            throw "Render error: missing partial for ".concat(node.key);

          default:
            console.warn("Render error: missing partial for ".concat(node.key));
            return "";
        }
      }

      try {
        return this._partials[node.key].render(node.incontext ? context : this._root, this._options);
      } catch (e) {
        console.log("Partial render error for '".concat(node.raw, "'"));
        console.warn(e);
        return "";
      }
    }
  }, {
    key: "_renderValue",
    value: function _renderValue(node, value) {
      var _this = this;

      var format = node.format,
          type = typeOf(value);
      if (type <= TYPES.NULL) return ""; // format list (unless not array, then normal handling)

      if (node.directive === directives.LIST && type === TYPES.ARRAY) {
        value = value.map(function (vi) {
          // multi-dimensional arrays simply converted to string
          if (Array.isArray(vi)) return "[".concat(vi.toString(), "]");
          return formatValue(vi, format, node.escape || _this._escapeAll);
        });

        switch (value.length) {
          case 0:
            return "";

          case 1:
            return value[0];

          case 2:
            return "".concat(value[0], " and ").concat(value[1]);

          default:
            var last = value.pop();
            return value.join(", ") + ", and ".concat(last);
        }
      } // other non-value types, convert to string


      switch (type) {
        case TYPES.ARRAY:
          value = "[".concat(value.toString(), "]");
          format = false;
          break;

        case TYPES.OBJECT:
          // be sure to clear parent reference before stringifying
          var objval = value,
              parentRef = objval._parent;
          delete objval._parent;
          value = JSON.stringify(objval);
          if (parentRef) objval._parent = parentRef;
          format = false;
          break;
      } // final format and add


      return formatValue(value, format, node.escape || this._escapeAll);
    }
  }, {
    key: "_mergeText",
    value: function _mergeText(input, out) {
      out = out || new RootNode();
      var text = "",
          node;

      for (var n = 0; n < input.inner.length; ++n) {
        node = input.inner[n];

        if (node instanceof TextNode) {
          text += node.text;
        } else {
          out.inner.push(new TextNode(text), node);
          text = "";
        }
      }

      if (text) out.inner.push(new TextNode(text));
      return out;
    }
  }]);

  return Interface;
}();

;
/* harmony default export */ var lib_interface = (interface_Interface);
// CONCATENATED MODULE: ./templatize.js


/* harmony default export */ var templatize = __webpack_exports__["default"] = ({
  render: function render(template, bindings, options) {
    return this.from(template, options).render(bindings, options);
  },
  from: function from(template, options) {
    return new lib_interface(new lib_template(template, options), options);
  }
});

/***/ })
/******/ ])["default"];
});